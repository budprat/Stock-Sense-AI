# Sprint 1 Implementation Guide

## Status: Schema Fixed âœ… | Routes & Storage: Ready for Implementation

### Completed Changes

âœ… **Schema Updates (Committed)**
- All user foreign keys changed from `integer` to `varchar`
- Added missing purchaseOrders fields (`isAutoGenerated`, `organizationId`, `createdBy`)
- Schema now consistent with Replit Auth requirements

### Next Steps: Storage Layer & Routes Refactoring

## Part 1: Update Storage Layer Interface (2-3 hours)

**File:** `server/storage.ts`

**Find & Replace Pattern:**
```typescript
// BEFORE (28 occurrences)
userId: number

// AFTER
userId: string
```

**Specific Changes Required:**

### Interface Changes (Lines 68-186)

```typescript
export interface IStorage {
  // User operations - ALREADY CORRECT âœ…
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;

  // Product operations - NEEDS UPDATE
  getProducts(userId: string): Promise<Product[]>;  // was number
  getProduct(id: number, userId: string): Promise<Product | undefined>;  // was number
  createProduct(product: InsertProduct & { userId: string }): Promise<Product>;  // was number
  updateProduct(id: number, product: Partial<InsertProduct>, userId: string): Promise<Product | undefined>;  // was number
  deleteProduct(id: number, userId: string): Promise<boolean>;  // was number

  // Inventory operations - NEEDS UPDATE
  getInventory(userId: string): Promise<InventoryWithProduct[]>;  // was number
  getInventoryItem(productId: number, userId: string): Promise<InventoryWithProduct | undefined>;  // was number
  getInventoryByProduct(userId: string, productId: number): Promise<Inventory | undefined>;  // was number
  createInventoryItem(item: InsertInventory & { userId: string }): Promise<Inventory>;  // was number
  updateInventoryItem(productId: number, item: Partial<InsertInventory>, userId: string): Promise<Inventory | undefined>;  // was number
  deleteInventoryByProductId(productId: number, userId: string): Promise<boolean>;  // was number

  // Supplier operations - NEEDS UPDATE
  getSuppliers(userId: string): Promise<Supplier[]>;  // was number
  getSupplier(id: number, userId: string): Promise<Supplier | undefined>;  // was number
  createSupplier(supplier: InsertSupplier & { userId: string }): Promise<Supplier>;  // was number
  updateSupplier(id: number, supplier: Partial<InsertSupplier>, userId: string): Promise<Supplier | undefined>;  // was number

  // AI recommendations - NEEDS UPDATE
  getAIRecommendations(userId: string): Promise<AIRecommendationWithProduct[]>;  // was number
  createAIRecommendation(recommendation: InsertAIRecommendation & { userId: string }): Promise<AIRecommendation>;  // was number
  updateAIRecommendation(id: number, recommendation: Partial<InsertAIRecommendation>, userId: string): Promise<AIRecommendation | undefined>;  // was number

  // Analytics - NEEDS UPDATE
  getInventoryHealth(userId: string): Promise<{...}>;  // was number
  getWasteRecords(userId: string): Promise<WasteRecord[]>;  // was number
  createWasteRecord(record: InsertWasteRecord & { userId: string }): Promise<WasteRecord>;  // was number
  getDashboardStats(userId: string): Promise<{...}>;  // was number
  getDemandForecast(userId: string, productId?: number): Promise<any[]>;  // was number

  // Spoilage - NEEDS UPDATE
  getSpoilageRisks(userId: string): Promise<any[]>;  // was number
  updateStorageConditions(productId: number, conditions: any, userId: string): Promise<void>;  // was number
}
```

### Implementation Changes (Lines 188+)

**Pattern for Each Method:**
```typescript
// BEFORE
async getProducts(userId: number): Promise<Product[]> {
  return await db
    .select()
    .from(products)
    .where(eq(products.userId, userId))  // Type error: userId is varchar in schema
    .orderBy(asc(products.name));
}

// AFTER
async getProducts(userId: string): Promise<Product[]> {
  return await db
    .select()
    .from(products)
    .where(eq(products.userId, userId))  // Now correct: both are varchar
    .orderBy(asc(products.name));
}
```

**Methods to Update:**
1. `getProducts(userId: string)` - Line 215
2. `getProduct(id, userId: string)` - Line 223
3. `createProduct(product & { userId: string })` - Line 231
4. `updateProduct(id, product, userId: string)` - Line 236
5. `deleteProduct(id, userId: string)` - Line 245
6. `getInventory(userId: string)` - Line 252
7. `getInventoryItem(productId, userId: string)` - Line 270
8. `createInventoryItem(item & { userId: string })` - Line 289
9. `updateInventoryItem(productId, item, userId: string)` - Line 294
10. `getInventoryByProduct(userId: string, productId)` - Line 303
11. `deleteInventoryByProductId(productId, userId: string)` - Line 311
12. `getSuppliers(userId: string)` - Line 318
13. `getSupplier(id, userId: string)` - Line 326
14. `createSupplier(supplier & { userId: string })` - Line 334
15. `updateSupplier(id, supplier, userId: string)` - Line 339
16. `getAIRecommendations(userId: string)` - Line 348
17. `createAIRecommendation(recommendation & { userId: string })` - Line 388
18. `updateAIRecommendation(id, recommendation, userId: string)` - Line 393
19. `getInventoryHealth(userId: string)` - Line 402
20. `getWasteRecords(userId: string)` - Line 447
21. `createWasteRecord(record & { userId: string })` - Line 455
22. `getDashboardStats(userId: string)` - Line 460
23. `getDemandForecast(userId: string, productId?)` - Line 500
24. `getSpoilageRisks(userId: string)` - Line 717
25. `updateStorageConditions(productId, conditions, userId: string)` - Line 722

---

## Part 2: Update Routes to Use String User IDs (4-6 hours)

**File:** `server/routes.ts`

### Step 2.1: Remove MOCK_USER_ID Constant

```typescript
// DELETE THIS (Line 51)
const MOCK_USER_ID = "1";
```

### Step 2.2: Update Each Route Pattern

**BEFORE (Wrong - Using Mock ID):**
```typescript
app.get("/api/dashboard/stats", async (req, res) => {
  try {
    const stats = await storage.getDashboardStats(parseInt(MOCK_USER_ID));
    res.json(stats);
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ message: "Failed to fetch stats" });
  }
});
```

**AFTER (Correct - Using Authenticated User):**
```typescript
app.get("/api/dashboard/stats", isAuthenticated, async (req: any, res) => {
  try {
    const userId = req.user.claims.sub;  // String from Replit Auth
    const stats = await storage.getDashboardStats(userId);
    res.json(stats);
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ message: "Failed to fetch stats" });
  }
});
```

### Routes Requiring Update (41 occurrences)

**Priority 1 - Dashboard & Core Features:**
1. `GET /api/dashboard/stats` (Line 196)
2. `GET /api/inventory` (Line 219)
3. `GET /api/inventory/health` (Line 252)
4. `POST /api/products` (Line 514)
5. `GET /api/products` (Line 550)
6. `PUT /api/products/:id` (Line 574)
7. `DELETE /api/products/:id` (Line 608)
8. `PUT /api/inventory/:productId` (Line 642)

**Priority 2 - AI & Analytics:**
9. `GET /api/recommendations` (Line 218)
10. `POST /api/recommendations` (Line 699)
11. `GET /api/spoilage/risks` (Line 803)
12. `GET /api/ai/recommendations` (Line 976)
13. `GET /api/ai/report` (Line 999)

**Priority 3 - Suppliers & Orders:**
14. `GET /api/suppliers` (Line 366)
15. `POST /api/suppliers` (Line 382)
16. `GET /api/waste` (Line 744)
17. `POST /api/waste` (Line 752)

**Priority 4 - Categories & Misc:**
18. `GET /api/categories` (Line 592)
19. `POST /api/categories` (Line 622)

### Step 2.3: Add Authentication Middleware

**All protected routes must include `isAuthenticated`:**

```typescript
// Add to route definition
app.get("/api/dashboard/stats", isAuthenticated, async (req: any, res) => {
  //                              ^^^^^^^^^^^^^^^^
});
```

### Step 2.4: Demo Initialization Route (Special Case)

```typescript
// BEFORE
app.post("/api/init-demo", async (req, res) => {
  const existingProducts = await storage.getProducts(parseInt(MOCK_USER_ID));
  //                                                 ^^^^^^^^ WRONG
});

// AFTER
app.post("/api/init-demo", isAuthenticated, async (req: any, res) => {
  const userId = req.user.claims.sub;
  const existingProducts = await storage.getProducts(userId);
  //                                                 ^^^^^^^^ CORRECT

  // Create user if needed
  if (!await storage.getUser(userId)) {
    await storage.upsertUser({
      id: userId,
      email: req.user.claims.email,
      firstName: req.user.claims.first_name,
      lastName: req.user.claims.last_name,
      businessType: req.body.businessType || "retail",
    });
  }

  // ... rest of demo initialization
});
```

---

## Part 3: Frontend Auth Context Rewrite (3-4 hours)

**File:** `client/src/contexts/auth-context.tsx`

**Current Problem:**
- Auth state stored in `localStorage`
- No connection to backend session
- `businessType` only exists in frontend

**Solution:**

```typescript
import { createContext, useContext, ReactNode } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  profileImageUrl?: string;
  businessType?: string;
  role: string;
  isActive: boolean;
}

interface AuthContextType {
  user: User | null | undefined;
  isLoading: boolean;
  login: () => void;
  logout: () => void;
  updateBusinessType: (type: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const queryClient = useQueryClient();

  // Fetch user from backend session
  const { data: user, isLoading } = useQuery({
    queryKey: ['/api', 'auth', 'user'],
    queryFn: async () => {
      try {
        const res = await fetch('/api/auth/user', { credentials: 'include' });
        if (res.status === 401) return null;
        if (!res.ok) throw new Error('Failed to fetch user');
        return await res.json();
      } catch (error) {
        console.error('Auth error:', error);
        return null;
      }
    },
    retry: false,
    staleTime: 5 * 60 * 1000,
  });

  const updateBusinessTypeMutation = useMutation({
    mutationFn: async (businessType: string) => {
      if (!user) throw new Error('No user');
      return apiRequest('PATCH', `/api/users/${user.id}`, { businessType });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api', 'auth', 'user'] });
    },
  });

  const login = () => {
    window.location.href = '/api/login';
  };

  const logout = () => {
    window.location.href = '/api/logout';
  };

  const updateBusinessType = async (type: string) => {
    await updateBusinessTypeMutation.mutateAsync(type);
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout, updateBusinessType }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

**Update `client/src/hooks/useAuth.ts`:**
```typescript
// DELETE THIS FILE - functionality moved to auth-context.tsx
```

---

## Part 4: Update Onboarding Page (1 hour)

**File:** `client/src/pages/onboarding.tsx`

**Change:**
```typescript
// BEFORE
const handleContinue = () => {
  if (businessType) {
    localStorage.setItem('user', JSON.stringify({ ...user, businessType }));
    navigate('/dashboard');
  }
};

// AFTER
const handleContinue = async () => {
  if (businessType) {
    await updateBusinessType(businessType);  // Saves to database
    navigate('/dashboard');
  }
};
```

---

## Part 5: Run Database Migration (30 mins)

```bash
# Push schema changes to database
npm run db:push

# If errors occur, may need to manually migrate data:
# 1. Backup database
# 2. Update user_id columns to varchar
# 3. Convert existing integer values to strings
```

**SQL Migration Script (if needed):**
```sql
-- Backup first!
-- Then for each table:
ALTER TABLE products ALTER COLUMN user_id TYPE varchar USING user_id::varchar;
ALTER TABLE inventory ALTER COLUMN user_id TYPE varchar USING user_id::varchar;
-- ... repeat for all tables
```

---

## Testing Checklist

### Unit Tests
- [ ] Storage methods accept string user IDs
- [ ] Routes extract userId from req.user.claims.sub
- [ ] Auth context queries backend correctly

### Integration Tests
1. **Login Flow:**
   - [ ] User clicks login
   - [ ] Replit Auth redirects back
   - [ ] Session created in PostgreSQL
   - [ ] Frontend queries /api/auth/user successfully

2. **Onboarding Flow:**
   - [ ] New user has no businessType
   - [ ] Onboarding page shown
   - [ ] Business type saved to database
   - [ ] User redirected to dashboard

3. **Data Access:**
   - [ ] Dashboard loads user's own inventory
   - [ ] Can't access other users' data
   - [ ] Demo mode disabled

### Manual Testing
```bash
# 1. Start dev server
npm run dev

# 2. Test login
# Navigate to http://localhost:5000
# Click login
# Complete Replit Auth
# Verify redirected to dashboard

# 3. Test data isolation
# Create a product
# Log out
# Log in as different user
# Verify can't see first user's products
```

---

## Common Errors & Solutions

### Error: "user_id type mismatch"
**Cause:** Forgot to update a storage method signature
**Fix:** Change `userId: number` to `userId: string`

### Error: "Cannot read property 'claims' of undefined"
**Cause:** Route missing `isAuthenticated` middleware
**Fix:** Add middleware to route

### Error: "parseInt is not defined"
**Cause:** Using old MOCK_USER_ID pattern
**Fix:** Use `req.user.claims.sub` instead

### Error: "401 Unauthorized"
**Cause:** Session not being sent
**Fix:** Ensure `credentials: 'include'` in fetch calls

---

## Estimated Timeline

| Task | Time | Complexity |
|------|------|------------|
| Storage layer interface | 30 mins | Low |
| Storage implementation | 1 hour | Low |
| Routes refactoring | 4-6 hours | Medium |
| Frontend auth context | 3 hours | Medium |
| Onboarding page | 1 hour | Low |
| Database migration | 30 mins | Medium |
| Testing & debugging | 4 hours | High |
| **TOTAL** | **12-16 hours** | **2-3 days** |

---

## Success Criteria

âœ… All routes use authenticated user ID from session
âœ… No parseInt(MOCK_USER_ID) references remain
âœ… Storage layer uses string user IDs consistently
âœ… Frontend auth synced with backend session
âœ… Business type stored in database
âœ… Database migration successful
âœ… All tests pass
âœ… Demo mode removed

---

## Files Modified Summary

```
server/storage.ts          - Interface & implementation (28 methods)
server/routes.ts           - Remove MOCK_USER_ID, add auth (41 routes)
client/src/contexts/auth-context.tsx  - Complete rewrite
client/src/pages/onboarding.tsx       - Update businessType save
client/src/hooks/useAuth.ts           - Delete (moved to context)
shared/schema.ts           - DONE âœ…
```

---

## Next Sprint Preview

After Sprint 1 is complete, Sprint 2 will add:
- Input validation with Zod
- Location-based filtering
- Cascade deletes
- Pagination
- Achievement auto-tracking

But first, complete Sprint 1! ðŸš€
